import{gc as B,ge as E,k3 as z,g2 as c,g1 as P,k9 as O,gA as v,wW as T,k2 as C,gx as L,gy as W,gz as R,wX as se,wY as Z,wZ as w,gf as re,h0 as ie,w_ as oe,g6 as H,jY as J,jW as ae,gF as me}from"./index-CQBquChn.js";function j(){return{outPoint:new P,index:-1,t:Number.NaN}}function G(m,e,t){return{outPoint:m.clone(),index:e,t}}function h(m,e,t,n){m.outPoint.assign(e),m.index=t,m.t=n}function S(m,e){m.outPoint.assign(e.outPoint),m.index=e.index,m.t=e.t}function K(m,e,t,n){m.index=t,m.t=n,e.queryCoord2D(m.t,m.outPoint)}function Y(m,e){const t=j();S(t,m),S(m,e),S(e,t)}function ue(m,e,t,n,s,i){if(m.getGeometryType()===c.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const r=n.nextSegment();if(O(m,r.getEndXY(),0)!==0)return h(s,r.getEndXY(),-1,Number.NaN),h(i,r.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}if(e.getGeometryType()===c.enumPolygon){for(;t.nextPath();)if(t.hasNextSegment()){const r=t.nextSegment();if(O(e,r.getEndXY(),0)!==0)return h(s,r.getEndXY(),-1,Number.NaN),h(i,r.getEndXY(),-1,Number.NaN),!0}t.resetToFirstPath()}return!1}function ce(m){const e=m.getPathCount(),t=ie(m.getSegmentCount(),0);let n=0;for(let s=0;s<e;++s){const i=n+m.getSegmentCountPath(s);for(let r=n,a=m.getPathStart(s);r<i;++r,++a)t[r]=a;n=i}return oe(m.getPointCount(),t),t}function Q(m,e){return!!Number.isNaN(e)||m<=e}function F(m){const e=new re;return e.addEnvelope(m,!1),e}class le{constructor(e,t){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=t,this.m_maxSqrDistance=e*e,this.m_maxDistance=e,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=e,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let n=Math.sqrt(this.m_maxSqrDistance);for(;n<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,n=Math.sqrt(this.m_maxSqrDistance)}}calculate(e,t,n,s){if((e.getGeometryType()!==B.type||t.getGeometryType()!==B.type)&&(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!Q(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const i=G(new P,w(),Number.NaN),r=G(new P,w(),Number.NaN),a=this._ExecuteBruteForce(e,t,i,r);return Q(a,this.m_maxDistance)?(n!==null&&S(n,i),s!==null&&S(s,r),a):Number.POSITIVE_INFINITY}isNear(e,t){if(this.m_bIsNearCalc=!0,e.isEmpty()||t.isEmpty())return!1;if(e===t)return!0;let n=!0;if(e.getGeometryType()!==B.type&&e.getGeometryType()!==z.type||t.getGeometryType()!==B.type&&t.getGeometryType()!==z.type||(n=!1),n){if(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const s=G(new P,w(),Number.NaN),i=G(new P,w(),Number.NaN);return this._ExecuteBruteForce(e,t,s,i)<=this.m_maxDistance}progress_(e=!1){}_ExecuteBruteForce(e,t,n,s){switch(e.getGeometryType()){case c.enumPoint:return this.distancePointGeometry(e,t,n,s);case c.enumMultiPoint:return this.distanceMultipointGeometry(e,t,n,s);case c.enumEnvelope:return this.distanceEnvelopeGeometry(e,t,n,s);case c.enumPolyline:case c.enumPolygon:return this.distanceMultipathGeometry(e,t,n,s);default:return Number.NaN}}distancePointGeometry(e,t,n,s){switch(t.getGeometryType()){case c.enumPoint:return this.distancePointPoint(e,t,n,s);case c.enumMultiPoint:return this.distancePointMultipoint(e,t,n,s);case c.enumPolyline:case c.enumPolygon:return this.distancePointMultipath(e,t,n,s);case c.enumEnvelope:return this.distancePointEnvelope(e,t,n,s);default:return Number.NaN}}distancePointPoint(e,t,n,s){const i=e.getXY(),r=t.getXY();return h(n,i,0,0),h(s,r,0,0),Math.sqrt(P.sqrDistance(i,r))}distancePointMultipoint(e,t,n,s){const i=e.getXY();let r=this.m_maxSqrDistance,a=r,o=!1;const u=t.getPointCount(),y=new P;for(let _=0;_<u;++_)if(t.queryXY(_,y),a=P.sqrDistance(i,y),this.m_bIsNearCalc){if(a<=r)return 0}else if(!(a>r)&&(!o&&a===r||a<r)&&(r=a,h(n,i,0,0),h(s,y,_,0),o=!0,r===0))return 0;return o?Math.sqrt(r):Number.POSITIVE_INFINITY}distancePointMultipath(e,t,n,s){const i=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),r=e.getXY();if(!i&&t.getGeometryType()===c.enumPolygon&&O(t,r,0)!==0)return h(n,r,0,0),h(s,r,-1,Number.NaN),0;t.getImpl().getAccelerators();let a=this.m_maxSqrDistance,o=a,u=-1;const y=new E,_=t.querySegmentIterator();let l=!1;for(;_.nextPath();)for(;_.hasNextSegment();){const p=_.nextSegment();p.queryEnvelope(y);const x=y.sqrDistance(r);if(x>a||!this.m_bIsNearCalc&&l&&x===a)continue;u=p.getClosestCoordinate(r,!1);const g=p.getCoord2D(u);if(o=P.sqrDistance(r,g),this.m_bIsNearCalc){if(o<=a)return 0}else if(!(o>a)&&(!l||o<a)&&(a=o,h(n,r,0,0),h(s,g,_.getStartPointIndex(),u),l=!0,a===0))return 0}return l?Math.sqrt(a):Number.POSITIVE_INFINITY}distancePointEnvelope(e,t,n,s){const i=e.getXY();h(n,i,0,0),h(s,i,-1,Number.NaN);const r=t.asEnvelope2D();return r.contains(i)?0:Math.sqrt(r.sqrDistance(i,s.outPoint))}distanceMultipointGeometry(e,t,n,s){switch(t.getGeometryType()){case c.enumPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distancePointMultipoint(t,e,s,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case c.enumMultiPoint:return this.distanceMultipointMultipoint(e,t,n,s,1,1);case c.enumPolyline:case c.enumPolygon:return this.distanceMultipointMultipath(e,t,n,s);case c.enumEnvelope:return this.distanceMultipointMultipath(e,F(t),n,s);default:return Number.NaN}}distanceMultipointMultipoint(e,t,n,s,i,r){const a={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&i===1&&r===1){const M=Math.trunc(T(Math.sqrt(e.getPointCount())+1,1,C())),I=Math.trunc(T(Math.sqrt(t.getPointCount())+1,1,C()));if((M>=4||I>=4)&&this.distanceMultipointMultipoint(e,t,n,s,M,I)<=this.m_maxSqrDistance)return 0}let o=this.m_maxSqrDistance;const u=[e],y=[t],_=this.swapGeometriesIfBGtA(u,y);_&&(this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r=v(i,i=r),Y(n,s)),L(a,W(()=>{Y(n,s),this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!_),!1);const l=u[0].getImpl(),p=y[0].getImpl(),x=l.getPointCount(),g=p.getPointCount(),q=g>1;let d=!1;const f=new P,D=new P;for(let M=0;M<x;M+=i){if(l.queryXY(M,f),q){const I=this.m_env2DgeometryB.sqrDistance(f);if(this.m_bIsNearCalc){if(I>o)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(f)<=o)return 0}else if(I>=o)continue}for(let I=0;I<g;I+=r){p.queryXY(I,D);const N=P.sqrDistance(f,D);if(this.m_bIsNearCalc){if(N<=o)return 0}else if(!(N>o||d&&N===o)&&(!d||N<o)&&(h(n,f,M,0),h(s,D,I,0),d=!0,o=N,o===0))return d?Math.sqrt(o):Number.POSITIVE_INFINITY}}return d?Math.sqrt(o):Number.POSITIVE_INFINITY}catch(o){a.error=o,a.hasError=!0}finally{R(a)}}distanceMultipointMultipath(e,t,n,s){let i=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&t.getGeometryType()===c.enumPolygon;const r=t.querySegmentIterator();r.stripAttributes();const a=new E,o=new P;let u=this.m_maxSqrDistance;const y=e.getImpl(),_=y.getPointCount(),l=_>1;let p=!1;for(;r.nextPath();)for(;r.hasNextSegment();){const x=r.nextSegment();if(x.queryLooseEnvelope(a),l){const g=a.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(g>u)continue}else if(g>u||p&&g===u)continue}for(let g=0;g<_;g++){if(y.queryXY(g,o),i&&O(t,o,0)!==0)return h(n,o,-1,Number.NaN),h(s,o,g,0),0;{const D=a.sqrDistance(o);if(this.m_bIsNearCalc){if(D>u)continue}else if(D>u)continue}const q=x.getClosestCoordinate(o,!1),d=x.getCoord2D(q);o.subThis(d);const f=o.sqrLength();if(this.m_bIsNearCalc){if(f<=u)return 0}else if(!(f>u)&&(!p||f<u)&&(u=f,h(n,y.getXY(g),g,0),h(s,d,r.getStartPointIndex(),q),p=!0,u===0))return 0}i=!1}return p?Math.sqrt(u):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(e,t,n,s){switch(t.getGeometryType()){case c.enumPoint:return this.distancePointEnvelope(t,e,s,n);case c.enumMultiPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distanceMultipointMultipath(t,F(e),s,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case c.enumPolyline:case c.enumPolygon:return this.distanceMultipathMultipath(F(e),t,n,s);case c.enumEnvelope:return this.distanceEnvelopeEnvelope(e,t,n,s);default:return Number.NaN}}distanceEnvelopeEnvelope(e,t,n,s){n.t=Number.NaN,n.index=-1,s.t=Number.NaN,s.index=-1;const i=e.asEnvelope2D(),r=t.asEnvelope2D();return Math.sqrt(i.sqrDistanceEnvelope(r,n.outPoint,s.outPoint))}distanceMultipathGeometry(e,t,n,s){switch(t.getGeometryType()){case c.enumPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distancePointMultipath(t,e,s,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case c.enumMultiPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distanceMultipointMultipath(t,e,s,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case c.enumPolyline:case c.enumPolygon:return this.distanceMultipathMultipath(e,t,n,s);case c.enumEnvelope:return this.distanceMultipathMultipath(e,F(t),n,s);default:return Number.NaN}}distanceMultipathMultipath(e,t,n,s){const i={stack:[],error:void 0,hasError:!1};try{const r=[e],a=[t],o=this.swapGeometriesIfAGtB(r,a);o&&(this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),Y(n,s)),L(i,W(()=>{Y(n,s),this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!o),!1);const u=r[0],y=a[0],_=u.querySegmentIterator();_.stripAttributes();const l=y.querySegmentIterator();if(l.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const N=Math.trunc(T(Math.sqrt(u.getPointCount())+1,1,C())),A=Math.trunc(T(Math.sqrt(u.getPointCount())+1,1,C()));if(this.distanceMultipointMultipoint(u,y,n,s,N,A)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const N=j(),A=j();if(ue(u,y,_,l,N,A))return S(n,N),S(s,A),0}const p=ce(u),x=[],g=new se,q=new E,d=new E,f=new E;let D=this.m_maxSqrDistance,M=!0,I=!1;for(let N=0,A=p.length;N<A;++N){u.querySegment(p[N],g,!0);const X=g.get();if(X.queryEnvelope(q),!(q.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>D)){if(this.m_bIsNearCalc&&q.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=D)return 0;for(;l.nextPath();){if(this.progress_(),M)y.queryPathEnvelope(l.getPathIndex(),f),x[l.getPathIndex()]=f.clone();else if(q.sqrDistanceEnvelope(x[l.getPathIndex()],null,null)>D)continue;for(;l.hasNextSegment();){const V=l.nextSegment();if(V.queryEnvelope(d),q.sqrDistanceEnvelope(d,null,null)<=D){const ne=!q.isIntersecting(d),k=[0],$=[0];let b=X.distance(V,ne,k,$);if(b*=b,this.m_bIsNearCalc&&b<=this.m_maxSqrDistance)return 0;if(b<D||b===D&&p[N]<n.index){if(I=!0,K(n,X,p[N],k[0]),K(s,V,l.getStartPointIndex(),$[0]),b===0)return 0;D=b}}}}l.resetToFirstPath(),M=!1}}return I?Math.sqrt(D):Number.POSITIVE_INFINITY}catch(r){i.error=r,i.hasError=!0}finally{R(i)}}swapGeometriesIfAGtB(e,t){return Z(e[0])>Z(t[0])&&(t[0]=v(e[0],e[0]=t[0]),!0)}swapGeometriesIfBGtA(e,t){return this.swapGeometriesIfAGtB(t,e)}}class he{getOperatorType(){return 10100}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}execute(e,t,n){return this.executeEx(e,t,n,null,null,Number.NaN)}executeEx(e,t,n,s,i,r){if(e.isEmpty()||t.isEmpty())return Number.NaN;H(e),H(t);const a=e,o=t;Number.isNaN(r)&&(r=Number.POSITIVE_INFINITY);const u=new le(r,n).calculate(a,o,s,i);return Number.isFinite(u)?u:Number.NaN}}const U=new he;function ee(m,e,t={}){const{unit:n}=t;let s=U.execute(J(m),J(e),null);if(s&&n){const i=ae(m);s=me(s,i,n)}return s}const te=U.supportsCurves(),ye=Object.freeze(Object.defineProperty({__proto__:null,execute:ee,supportsCurves:te},Symbol.toStringTag,{value:"Module"})),_e=Object.freeze(Object.defineProperty({__proto__:null,execute:ee,supportsCurves:te},Symbol.toStringTag,{value:"Module"}));export{_e as d,ye as i};
