import{gb as x,ga as D,gc as v,g6 as z,gt as w,g2 as f,gf as C,g7 as G,gd as E,gu as R,gl as S,gv as T,gw as X,gx as Y,gy as b,gz as I,g1 as P,gA as N}from"./index-DrZ9WlpE.js";class F{getOperatorType(){return 10204}supportsCurves(){return!0}accelerateGeometry(t,e,a){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,a,n){return new y(t,e,a,n)}execute(t,e,a,n){return t||x("null param is not allowed."),new y(null,e,a,n).generalize(t)}}class y extends D{constructor(t,e,a,n){super(),this.m_pline=null,this.m_point=new v,this.m_stack=[],this.m_resultstack=[],this.m_callCount=0,this.m_progressTracker=n,this.m_geoms=t,this.m_maxDeviation=e,this.m_bRemoveDegenerateParts=a}tock(){return!0}getRank(){return 1}next(){const t=this.m_geoms.next();return t===null?null:(z(t),this.generalize(t))}getGeometryID(){return this.m_geoms.getGeometryID()}generalize(t){const e=t.getGeometryType();if(w(e))return t;if(e===f.enumEnvelope){const s=new C({vd:t.getDescription()});return s.addEnvelope(t,!1),this.generalize(s)}if(G(e)){const s=new E({vd:t.getDescription()});return s.addSegment(t,!0),this.generalize(s)}if(R(e)||S(""),t.isEmpty()||this.m_maxDeviation<=0)return t;const a=new T().execute(t,0,.05*this.m_maxDeviation,0,this.m_progressTracker);t.hasNonLinearSegments()&&(this.m_maxDeviation*=.95);const n=a,h=t.createInstance();h.getGeometryType()===f.enumPolygon&&h.setFillRule(t.getFillRule()),this.m_xy=n.getAttributeStreamRef(0);{const s={stack:[],error:void 0,hasError:!1};try{const m=new X;this.m_pline=m,Y(s,b(()=>{this.m_pline=null},!1),!1);for(let r=0,l=n.getPathCount();r<l;r++)this.generalizePath(n.getImpl(),r,h.getImpl())}catch(m){s.error=m,s.hasError=!0}finally{I(s)}}return this.m_resultstack.length=0,this.m_stack.length=0,h}generalizePath(t,e,a){if(t.getPathSize(e)<2)return;this.m_resultstack.length=0,this.m_stack.length=0;const n=t.getPathStart(e),h=t.getPathEnd(e)-1,s=t.isClosedPath(e),m=t.isClosedPathInXYPlane(e);let r=0,l=-1;this.m_stack.push(s?n:h),this.m_stack.push(n);let o=!1,c=!1;for(!this.m_bRemoveDegenerateParts&&m&&(o=!0,c=!0);this.m_stack.length>1;){const i=this.m_stack.at(-1);this.m_stack.pop();const _=this.m_stack.at(-1);let p=t.getXY(i);this.m_pline.setStartXY(p),p=t.getXY(_),this.m_pline.setEndXY(p);const k=[Number.NaN];let u=this.findGreatestDistance(i,_,h,k);u>=0&&(o?o=!1:(c&&k[0]>r&&(r=k[0],l=u),k[0]<=this.m_maxDeviation&&(u=-1))),u>=0?(this.m_stack.push(u),this.m_stack.push(i)):this.m_resultstack.push(i)}s||this.m_resultstack.push(this.m_stack[0]);const g=this.m_resultstack.length;if(g===t.getPathSize(e)&&g===this.m_stack.length)a.addPath(t,e,!0);else if(this.m_resultstack.length>0){if(this.m_bRemoveDegenerateParts&&this.m_resultstack.length<=2&&(s||this.m_resultstack.length===1||P.distance(t.getXY(this.m_resultstack[0]),t.getXY(this.m_resultstack[1]))<=this.m_maxDeviation))return;if(c&&l>=0&&r<=this.m_maxDeviation){const i=this.m_resultstack.at(-1)>l;this.m_resultstack.push(l),i&&(this.m_resultstack[this.m_resultstack.length-2]=N(this.m_resultstack[this.m_resultstack.length-1],this.m_resultstack[this.m_resultstack.length-1]=this.m_resultstack[this.m_resultstack.length-2]))}for(let i=0,_=this.m_resultstack.length;i<_;i++)t.getPointByVal(this.m_resultstack[i],this.m_point),i===0?a.startPathPoint(this.m_point):a.lineToPoint(this.m_point);if(s){for(let i=this.m_resultstack.length;i<3;i++)a.lineToPoint(this.m_point);a.closePathWithLine()}}}findGreatestDistance(t,e,a,n){let h=e-1;e<=t&&(h=a);let s=-1,m=0;const r=new P;for(let l=t+1;l<=h;l++){this.m_xy.queryPoint2D(2*l,r);const o=r.x,c=r.y,g=this.m_pline.getClosestCoordinate(r,!1);r.assign(this.m_pline.getCoord2D(g)),r.x-=o,r.y-=c;const i=r.length();i>m&&(s=l,m=i),this.m_callCount++}return n[0]=m,s}}export{F as P};
