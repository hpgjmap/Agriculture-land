import{g5 as a,g6 as m,g2 as i,g7 as l,g8 as f,g9 as h,ds as d,ga as G,gb as x,gc as s,gd as y,ge as M,gf as X,gg as _,gh as Y,gi as v}from"./index-CQBquChn.js";class q{getOperatorType(){return 10102}supportsCurves(){return!1}accelerateGeometry(r,u,n){return!1}canAccelerateGeometry(r){return!1}executeMany(r,u,n){return new w(u,r,n)}execute(r,u){return C(r)}isConvex(r,u){if(a(r),m(r),r.isEmpty())return!0;const n=r.getGeometryType();if(n===i.enumPoint)return!0;if(n===i.enumEnvelope){const o=r;return o.getXMin()!==o.getXMax()&&o.getYMin()!==o.getYMax()}if(l(n)){const o=r;return!o.getStartXY().equals(o.getEndXY())}if(n===i.enumMultiPoint)return r.getPointCount()===1;if(n===i.enumPolyline){const o=r;return o.getPathCount()===1&&o.getPointCount()===2&&!o.getXY(0).equals(o.getXY(1))}if(n===i.enumGeometryCollection){const o=r;return o.getGeometryCount()===1&&this.isConvex(o.getGeometry(0),u)}const t=r;return!(t.getPathCount()!==1||t.getPointCount()<3)&&f(t,0)}constructOrientedMinimumBoundingBox(r,u,n,t,o){h(r,u,n,t,o)}}class w extends G{constructor(r,u,n){super(),u||x(""),this.m_progressTracker=n,this.m_index=-1,this.m_bMerge=r,this.m_bDone=!1,this.m_inputGeometryCursor=u}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge){if(!this.m_bDone){const r=p(this.m_inputGeometryCursor);return this.m_bDone=!0,r}return null}if(!this.m_bDone){const r=this.m_inputGeometryCursor.next();if(r!==null)return a(r),m(r),this.m_index=this.m_inputGeometryCursor.getGeometryID(),C(r);this.m_bDone=!0}return null}}function p(e,r){const u=new v;let n;for(;n=e.next();)a(n),m(n),u.addGeometry(n);return u.getBoundingGeometry()}function C(e,r){if(e||x(""),a(e),m(e),e.isEmpty())return e.createInstance();const u=e.getGeometryType();if(l(u)){const n=e;if(n.getStartXY().equals(n.getEndXY())){const t=new s;return n.queryStart(t),t}{const t=new s,o=new y({vd:e.getDescription()});return n.queryStart(t),o.startPathPoint(t),n.queryEnd(t),o.lineToPoint(t),o}}if(u===i.enumEnvelope){const n=e,t=new M;if(n.queryEnvelope(t),t.xmin===t.xmax&&t.ymin===t.ymax){const o=new s;return n.queryCornerByVal(0,o),o}if(t.xmin===t.xmax||t.ymin===t.ymax){const o=new s,c=new y({vd:e.getDescription()});return n.queryCornerByVal(0,o),c.startPathPoint(o),n.queryCornerByVal(1,o),c.lineToPoint(o),c}{const o=new X({vd:e.getDescription()});return o.addEnvelope(n,!1),o}}if(u===i.enumGeometryCollection)return p(_(e,-1));if(P(e)){if(u===i.enumMultiPoint){const n=e,t=new s;return n.getPointByVal(0,t),t}return e}return Y(e)}function P(e,r){if(a(e),m(e),e.isEmpty())return!0;const u=e.getGeometryType();if(u===i.enumPoint)return!0;if(u===i.enumEnvelope){const t=e;return t.getXMin()!==t.getXMax()&&t.getYMin()!==t.getYMax()}if(l(u)){const t=e;return!t.getStartXY().equals(t.getEndXY())}if(u===i.enumMultiPoint)return e.getPointCount()===1;if(u===i.enumPolyline){const t=e;return t.getPathCount()===1&&t.getPointCount()===2&&!t.getXY(0).equals(t.getXY(1))}if(u===i.enumGeometryCollection){const t=e;return t.getGeometryCount()===1&&P(t.getGeometry(0))}const n=e;return!(n.getPathCount()!==1||n.getPointCount()<3)&&f(n,0)}const g=new q;function D(e){return g.execute(e,null)}function b(e,r){const u=g.executeMany(new d(e),r,null);return Array.from(u)}function B(e){return g.isConvex(e,null)}function T(){return g.supportsCurves()}export{D as M,T as X,B as _,b as v};
